#+TITLE: Golang Interfaces
#+STARTUP: showeverything

* Overview
An interface is applied to all structs automatically, so long as they share the have the values specified in
the interface. For example, if we make the following struct:
#+begin_src go
type Animal interface {
    eat() error
    sleep() error
}
#+end_src
Then any struct that contains methods ~eat()~ and ~sleep()~ where each returns an ~error~, will have the interface applied.
The following struct would have the interface mentioned above applied automatically:
#+begin_src go
type Cat struct {
    hungry bool
    tired bool
}
func(cat Cat) eat() error {
    fmt.Println("The cat is eating")
    cat.hungry = false
    return nil
}
func(cat Cat) sleep() error {
    fmt.Println("The cat is sleeping")
    cat.tired = false
    return nil
}
#+end_src
But the following would not, because it does not implement all the attributes of the interface:
#+begin_src go
type Cat struct {
    hungry bool
    tired bool
}
func(cat Cat) eat() error {
    fmt.Println("The cat is eating")
    cat.hungry = false
    return nil
}
#+end_src
If the interface applied to a struct, you can pass the struct to a function that expects the interface applied as a parameter,
such as:
#+begin_src go
package main
import "fmt"

type Animal interface {
    eat() error
    sleep() error
}
type Cat struct {
    hungry bool
    tired bool
}
type Dog struct {
    hungry bool
    tired bool
}
func(cat Cat) eat() error {
    fmt.Println("The cat is eating")
    cat.hungry = false
    return nil
}
func(dog Dog) eat() error {
    fmt.Println("The dog is eating")
    dog.hungry = false
    return nil
}
func live(animal Animal) error {
    animal.eat()
    animal.sleep()
}
func main() {
    cat := Cat{hungry: true, tired: true}
    dog := Dog{hungry: true, tired: true}
    live(cat)
    live(dog)
}
#+end_src
Would output:
#+begin_src 
The cat is eating
The dog is eating
#+end_src
Because both cat and dog have both ~sleep()~ and ~eat()~ methods which return errors, they automatically implement the interface,
and can be passed to the ~live()~ function

* Empty interfaces
An empty interface is basically a blank slate, represented by ~interface {}~, these are useful for passing a value
of a varying type. For instance:
#+begin_src go
package main

import (
    "fmt"
    "math/rand"
)

func unknown(i int) interface{} {
    if i < 0 {
      return true
    }
    if i == 0 {
      return "Equal to 0"
    }
    if i > 0 {
      return 1
    }
    return false			
}

func main() {
    // Random number between -5 and 5
    returned := unknown(rand.Intn(11) - 5)
    fmt.Printf("Type of returned: %T\n",returned)
    fmt.Println(returned)
}
#+end_src
The following function in ~unknown()~ could return a ~bool~, ~string~, or an ~int~. This is useful to get
around the limitations of a statically typed language. If you want to ensure the type returned is
the value type you're looking for, check into type assertions. The code would output one of the following:

*** If the number is less than 0:
#+begin_src 
Type of returned: bool
true
#+end_src
*** If the number is equal to 0:
#+begin_src
Type of returned: string
Equal to 0
#+end_src
*** If the number is more than 0:
#+begin_src 
Type of returned: int
1
#+end_src

